{
  "api/TrueMyth.Unsafe.UnsafeExtensions.html": {
    "href": "api/TrueMyth.Unsafe.UnsafeExtensions.html",
    "title": "Class UnsafeExtensions | True Myth",
    "keywords": "Class UnsafeExtensions Extensions to the Maybe<TValue> and Result<TValue, TError> implementations; the use of these methods is discouraged by organizing them this way. Inheritance System.Object UnsafeExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TrueMyth.Unsafe Assembly : TrueMyth.dll Syntax public static class UnsafeExtensions Methods | Improve this Doc View Source UnsafelyUnwrap<T>(Maybe<T>) Get the TValue value out of the Maybe<TValue> . Returns the content of a Just , but throws if the Maybe is Nothing . Prefer to use UnwrapOr(TValue) or UnwrapOrElse(Func<TValue>) . Declaration public static T UnsafelyUnwrap<T>(this Maybe<T> maybe) Parameters Type Name Description Maybe <T> maybe Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source UnsafelyUnwrap<T, E>(Result<T, E>) Get the value out of the Result . Returns the content of an Ok but throws if the result is Err . Prefer to use UnwrapOr(TValue) or UnwrapOrElse(Func<TError, TValue>) Declaration public static T UnsafelyUnwrap<T, E>(this Result<T, E> result) Parameters Type Name Description Result <T, E> result Returns Type Description T Type Parameters Name Description T E | Improve this Doc View Source UnsafelyUnwrapErr<T, E>(Result<T, E>) Get the error out of the Result . Returns the content of an Err , but throws if the result is Ok . Prefer to use UnwrapOrElse(Func<TError, TValue>) . Declaration public static E UnsafelyUnwrapErr<T, E>(this Result<T, E> result) Parameters Type Name Description Result <T, E> result Returns Type Description E Type Parameters Name Description T E"
  },
  "api/TrueMyth.Maybe-1.html": {
    "href": "api/TrueMyth.Maybe-1.html",
    "title": "Class Maybe<TValue> | True Myth",
    "keywords": "Class Maybe<TValue> A Maybe<T> represents a value of type T which may, or may not, be present. If the value is present, it is Just a value. If it's absent, it's Nothing . This provides a type-safe container for dealing with the possibility that there's nothing here ‚Äî a container you can do many of the same things you might with an array ‚Äî so that you can avoid nasty null checks throughout your codebase. The behavior of this type is checked by the C‚ôØ compiler and bears no runtime overhead other than the very small cost of the container object and some lightweight wrap/unwrap functionality. The Nothing and Just variants are represented internally to the Maybe<T> object and is exposed in several ways. The most explicit way to check if a Maybe<T> is Just or Nothing is through the IsJust and IsNothing properties, respectively. Inheritance System.Object Maybe<TValue> Implements System.IComparable System.IComparable < Maybe <TValue>> Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : TrueMyth Assembly : TrueMyth.dll Syntax public sealed class Maybe<TValue> : IComparable, IComparable<Maybe<TValue>> Type Parameters Name Description TValue Any type supported by the .NET type system. Examples // simple way to construct a Maybe <int> var aKnownNumber = Maybe<int>.Just(7); // once you have it, you can apply methods to it var fromMappedJust = aKnownNumber.Select(x => x * 2).Unwrap(0); Console.WriteLine(fromMappedJust); // \"Just<int>[14]\" // construct a Nothing where you don't have a value to use, but the function // requires a value var aKnownNothing = Maybe<int>.Nothing; // the same operations will behave as safely on a Nothing as on a Just: var fromMappedNothing = aKnownNothing.Select(x => x * 2).Unwrap(0); Console.WriteLine(fromMappedNothing); // \"Just<int>[0]\" // construct a Maybe where you don't know where the value will exist or not, using a // null check to decide which to construct string unknownValue = someFunction(); var wrappedUnkonwn = unknownValue == null ? Maybe<string>.Just(unknownValue) : Maybe<string>.Nothing; Console.WriteLine(wrappedUnknown);// either \"Just<string>[...]\" or \"Nothing<string>\" Properties | Improve this Doc View Source IsJust Explicit means by which to determine if a Maybe<TValue> is a Just . Returns true if Just and false if Nothing . Opposite of IsNothing . Declaration public bool IsJust { get; } Property Value Type Description System.Boolean | Improve this Doc View Source IsNothing Explicit means by which to determin if a Maybe<TValue> is a Nothing . Returns true if Nothing and false if Just . Exactly the opposite of IsJust . Declaration public bool IsNothing { get; } Property Value Type Description System.Boolean | Improve this Doc View Source Nothing Static property representing a Nothing of type Maybe<TValue> ; only constructed once during static initialization of the program, so this property is effectively like a constant. Declaration public static Maybe<TValue> Nothing { get; } Property Value Type Description Maybe <TValue> The Nothing instance of type Maybe<TValue> . Methods | Improve this Doc View Source And<UValue>(Maybe<UValue>) You can think of this like a short-circuiting logical \"and\" operation on a Mabye type. If this is a Just , then the result is the andMaybe . If this is Nothing , then the result will also be Nothing for the destination type Maybe<UValue> . This is useful when you have another Maybe value you want to provide iff you have a Just ‚Äî that is, when you need to make sure that if you have Nothing , whatever else you're handing a Maybe also gets a Nothing . Other things to note: Declaration public Maybe<UValue> And<UValue>(Maybe<UValue> andMaybe) Parameters Type Name Description Maybe <UValue> andMaybe Returns Type Description Maybe <UValue> Type Parameters Name Description UValue | Improve this Doc View Source AndThen<UValue>(Func<TValue, Maybe<UValue>>) This work similarly to And<UValue>(Maybe<UValue>) , but instead of providing a maybe that will be returned when this is Just , you provide a function that returns a Maybe . Declaration public Maybe<UValue> AndThen<UValue>(Func<TValue, Maybe<UValue>> bindFn) Parameters Type Name Description System.Func <TValue, Maybe <UValue>> bindFn Function that returns a Maybe<UValue> Returns Type Description Maybe <UValue> Type Parameters Name Description UValue Any type supported by C‚ôØ; it needn't be the same as TValue . | Improve this Doc View Source CompareTo(Object) Declaration public int CompareTo(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Int32 | Improve this Doc View Source CompareTo(Maybe<TValue>) Declaration public int CompareTo(Maybe<TValue> otherMaybe) Parameters Type Name Description Maybe <TValue> otherMaybe Returns Type Description System.Int32 | Improve this Doc View Source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this Doc View Source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this Doc View Source Map<UValue>(Func<TValue, UValue>) Map over a Maybe instance.static This applies the function to the wrapped value if the instance is Just and returns Nothing if the instance is Nothing . This respects types, so if this is of type Maybe<int> and you provide a mapFn of type Func<double> , the type of Maybe that will be returned will be Maybe<double> , irrespective of this being Just or Nothing . Declaration public Maybe<UValue> Map<UValue>(Func<TValue, UValue> mapFn) Parameters Type Name Description System.Func <TValue, UValue> mapFn The mapping function to be applied to the wrapped value. Returns Type Description Maybe <UValue> Type Parameters Name Description UValue The type of the resulting Maybe value. | Improve this Doc View Source MapReturn<UValue>(Func<TValue, UValue>, UValue) Map over a Maybe<TValue> instance and get out the value if it's a Just , or return a default value if it's a Nothing >. It differs from Map<UValue>(Func<TValue, UValue>) in that the result is the value type itself (or a mapped type). Declaration public UValue MapReturn<UValue>(Func<TValue, UValue> mapFn, UValue defaultValue) Parameters Type Name Description System.Func <TValue, UValue> mapFn The mapping function to be applied to the wrapped value. UValue defaultValue A fallback value of type UValue to be returned in the case that this is Nothing . Returns Type Description UValue A UValue as computed by mapFn if this is Just ; otherwise, the defaultValue . Type Parameters Name Description UValue The type of the result of the mapping function; any type supported by C‚ôØ can be used here; it needn't be different than TValue . | Improve this Doc View Source Match(Action<TValue>, Action) Provides a similar functionality as Match<UValue>(Func<TValue, UValue>, Func<UValue>) , but without return types. Declaration public void Match(Action<TValue> just, Action nothing) Parameters Type Name Description System.Action <TValue> just System.Action nothing | Improve this Doc View Source Match<UValue>(Func<TValue, UValue>, Func<UValue>) Provides the same basic functionality as UnwrapOrElse(Func<TValue>) , but instead of simply unwrapping the value if it is Just and applyiung a value to genearte the same default type if it is Nothing , lets you supply functions which may transform the wrapped type if it is Just or get a default value for Nothing . Declaration public UValue Match<UValue>(Func<TValue, UValue> just, Func<UValue> nothing) Parameters Type Name Description System.Func <TValue, UValue> just The function to apply if this is Just . System.Func <UValue> nothing The function to apply if this is Nothing . Returns Type Description UValue Type Parameters Name Description UValue Examples var maybeValue = fromSomeMethod(); var stringValue = maybeValue.Match( just: val => val.ToString(), nothing: val => \"nothing\" ); | Improve this Doc View Source Of(TValue) Static factory method for creation of new Just Maybe<TValue> s. If value is a reference type and is null , this returns a Nothing . Declaration public static Maybe<TValue> Of(TValue value) Parameters Type Name Description TValue value The value to be held by the Maybe<TValue> instance. Of type TValue (see documentation for Maybe<TValue> ). Returns Type Description Maybe <TValue> A Maybe<TValue> instance. | Improve this Doc View Source Or(Maybe<TValue>) Provide a fallback for this . Behaves like a logical \"or\": if the Maybe is Just , returns that; otherwise, returns the provided maybe . Declaration public Maybe<TValue> Or(Maybe<TValue> maybe) Parameters Type Name Description Maybe <TValue> maybe Fallback value. Returns Type Description Maybe <TValue> If this is Just , return this ; otherwise return maybe . | Improve this Doc View Source OrElse(Func<Maybe<TValue>>) Like Or(Maybe<TValue>) , but using a function to construct the fallback Maybe . Declaration public Maybe<TValue> OrElse(Func<Maybe<TValue>> elseFn) Parameters Type Name Description System.Func < Maybe <TValue>> elseFn Function used to construct fallback Maybe . Returns Type Description Maybe <TValue> If this is Just , returns this . Otherwise, returns result of elseFn . | Improve this Doc View Source Select<UValue>(Func<TValue, UValue>) An alias for Map<UValue>(Func<TValue, UValue>) ; provided for familiarity for C‚ôØ programmers. Declaration public Maybe<UValue> Select<UValue>(Func<TValue, UValue> mapFn) Parameters Type Name Description System.Func <TValue, UValue> mapFn The mapping function to be applied to the wrapped value. Returns Type Description Maybe <UValue> Type Parameters Name Description UValue The type of the resulting Maybe value. | Improve this Doc View Source ToResult<TError>(TError) Transform the Maybe into a Result<TValue, TError> , using the wrapped value as the Ok value if Just ; otherwise using the supplied error value for Err . Declaration public Result<TValue, TError> ToResult<TError>(TError error) Parameters Type Name Description TError error The error value to use if the Maybe is Nothing . Returns Type Description Result <TValue, TError> Type Parameters Name Description TError The wrapped value type. | Improve this Doc View Source ToResult<TError>(Func<TError>) Very similar to ToResult<TError>(TError) , but using a function to construct the error result. Declaration public Result<TValue, TError> ToResult<TError>(Func<TError> errFn) Parameters Type Name Description System.Func <TError> errFn Returns Type Description Result <TValue, TError> Type Parameters Name Description TError | Improve this Doc View Source ToString() Produces a string format like the following: \"Just<TValue>[value]\" or \"Nothing<TValue>\". Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() | Improve this Doc View Source UnwrapOr(TValue) Safely get the TValue value out of the Maybe<TValue> . Returns the content of Just or defaultValue if this is Nothing . This is the recommended way to get a value out of a Maybe most of the time. Declaration public TValue UnwrapOr(TValue defaultValue) Parameters Type Name Description TValue defaultValue Returns Type Description TValue | Improve this Doc View Source UnwrapOrElse(Func<TValue>) Safely get the value out of a Maybe by returning the wrapped value if it is Just , oir by applying elseFn if it's Nothing . This is useful when you need to generate a value (e.g. by using current values in the environment ‚Äî whether preloaded or by local closure) instead of having a default value available as in UnwrapOr(TValue) . Declaration public TValue UnwrapOrElse(Func<TValue> elseFn) Parameters Type Name Description System.Func <TValue> elseFn Returns Type Description TValue Operators | Improve this Doc View Source Explicit(Maybe<TValue> to TValue) Equivalent of UnsafelyUnwrap<T>(Maybe<T>) . Follows usual C‚ôØ semantics of throwing an exception at runtime if the conversion is invalid. Declaration public static explicit operator TValue(Maybe<TValue> maybe) Parameters Type Name Description Maybe <TValue> maybe Returns Type Description TValue | Improve this Doc View Source Implicit(TValue to Maybe<TValue>) Constructs a Maybe<TValue> explicitly. Equivalent of Of(TValue) . Declaration public static implicit operator Maybe<TValue>(TValue value) Parameters Type Name Description TValue value Returns Type Description Maybe <TValue> Examples This is useful for reducing ceremony when using TrueMyth, particularly when refactoring into existing code. Without TrueMyth at all, you might have a method like this: string GetTranslation(string sourceText) { string result = null; result = translationService.Lookup(sourceText); if (result == null) { throw new Exception($\"didn't find translation of '{sourceText}'.\"); } return result; } But since TrueMyth wants to help you stop using exceptions for control flow, you might rewrite it like this: Maybe<string> GetTranslation(string sourceText) { string result = null; // lookup translation result = translationService.Lookup(sourceText); return Maybe<string>.Of(result); } However, this is somewhat verbose. It's annoying to have to specify to the type system what you mean when it should already know. Instead, using the type system and this implicit operator, you can write the following. Maybe<string> GetTranslation(string sourceText) { string result = null; // lookup translation result = translationService.Lookup(sourceText); return result; } Implements System.IComparable System.IComparable<T> Extension Methods UnsafeExtensions.UnsafelyUnwrap<T>(Maybe<T>)"
  },
  "api/TrueMyth.html": {
    "href": "api/TrueMyth.html",
    "title": "Namespace TrueMyth | True Myth",
    "keywords": "Namespace TrueMyth Classes Maybe A static class that provides factory and extension methods for Maybe<TValue> . Maybe<TValue> A Maybe<T> represents a value of type T which may, or may not, be present. If the value is present, it is Just a value. If it's absent, it's Nothing . This provides a type-safe container for dealing with the possibility that there's nothing here ‚Äî a container you can do many of the same things you might with an array ‚Äî so that you can avoid nasty null checks throughout your codebase. The behavior of this type is checked by the C‚ôØ compiler and bears no runtime overhead other than the very small cost of the container object and some lightweight wrap/unwrap functionality. The Nothing and Just variants are represented internally to the Maybe<T> object and is exposed in several ways. The most explicit way to check if a Maybe<T> is Just or Nothing is through the IsJust and IsNothing properties, respectively. Result A static class that provides factory and extension methods for Result<TValue, TError> . Result<TValue, TError> A Result<TValue,TError> is a type representing the value result of an operation which may fail, with a successful value type of TValue or an error type of TError (pun intended!). If the value is present, it is Ok , and if absent, it's Err . There are several ways to check if a Result is Ok or Err , but the most direct and explicit are the IsOk and IsErr properties. This provides a type-safe container for dealing with the possibility that an error occurred, without needing to scatter try / catch blocks throughout your codebase. This has two major advantages: You know when an item may have a failure case, unlike cases in which exceptions are thrown (which may be thrown from any function with no warning and no help from the type system). The error scenario is a first-class citizen, and the provided helper functions and methods allow you to deal with the type in much the same way as you might an array ‚Äî transforming values if present, or dealing with errors instead of necessary."
  },
  "index.html": {
    "href": "index.html",
    "title": "Introduction | True Myth",
    "keywords": "Introduction True Myth provides standard, type-safe wrappers and helper functions to help you with two extremely common cases in programming: not having a value ‚Äî which it solves with a Maybe type and associated helper functions and methods having a result where you need to deal with either success or failure ‚Äî which it solves with a Result type and associated helper functions and methods You could implement all of these yourself ‚Äì it‚Äôs not hard! ‚Äì but it‚Äôs much easier to just have one extremely well-tested library you can use everywhere to solve this problem once and for all. Even better to get one of these with no runtime overhead for using it other than the very small cost of some little container objects ‚Äî which we get by leaning hard on the type system in C‚ôØ. Aside: If you‚Äôre familiar with LanguageExt , you'll see that this has a lot in common with it ‚Äî its main differences are: True Myth has a much smaller API surface than LanguageExt True Myth aims to be much more approachable for people who aren‚Äôt already super familiar with functional programming concepts and jargon Maybe Sometimes you don‚Äôt have a value. In C‚ôØ (and .NET generally), we usually represent that with a null - either directly or by a Nullable<T> ‚Äî and then trying to program defensively in the places we think we might get null as arguments to our functions. For example, imagine an endpoint which returns a JSON payload shaped like this: { \"hopefullyAString\": \"Hello!\" } But sometimes it might come over like this: { \"hopefullyAString\": null } Or even like this: {} Assume we were doing something simple, like logging the length of whatever string was there or logging a default value if it was absent. In typical C‚ôØ we‚Äôd write something like this: void LogValue(PayloadDto payload) { var length = payload?.hopefullyAString?.Length(); loger.Debug(\"Payload length: {length}\", length); } async Task RequestFromApi() { await client.FetchFromApi() .ContinueWith(payload => { LogValue(payload); // other stuff with payload ... }); } This isn‚Äôt a big deal right here‚Ä¶ but ‚Äî and this is a big deal ‚Äî we have to remember to do this everywhere we interact with this payload. The property hopefullyAString can always be null everywhere we interact with it, anywhere in our program. üò¨ Maybe is our escape hatch. If, instead of just naively interacting with the payload, we do a very small amount of work up front to normalize the data and use a Maybe instead of passing around null values, we can operate safely on the data throughout our application. If we have something, we get Maybe called Just ‚Äî as in, ‚ÄúWhat‚Äôs in this field? Just a string‚Äù or ‚ÄúJust the string ‚Äòhello‚Äô‚Äù. If there‚Äôs nothing there, we have a Maybe called Nothing . Maybe is a wrapper type that holds the actual value in it, and Just and Nothing are the valid states for that type. You‚Äôll never get a NullReferenceException (\"object reference not set to an instance of an object\") when trying to use it! Importantly, you can do a bunch of neat things with a Maybe instance without checking whether it‚Äôs a Nothing or a Just . For example, if you want to double a number if it‚Äôs present and do nothing if it isn‚Äôt, you can use the Maybe.Map function: var hereIsANumber = Maybe.Of(42); // Maybe<int> var hereIsNothing = Maybe<int>.Nothing; int doubleFn = n => n * 2; hereIsANumber.Map(doubleFn); // Just 84 hereIsNothing.Map(doubleFn); // Nothing There are a lot of those helper functions and methods ! Just about any way you would need to interact with a Maybe is there. So now that we have a little idea what Maybe is for and how to use it, here‚Äôs that same example, but rewritten to normalize the payload using a Maybe instance. We‚Äôre using C‚ôØ, so we will get a compiler error if we don‚Äôt handle any of these cases right ‚Äî or if we try to use the value at hopefullyAString directly after we‚Äôve normalized it! class PayloadDto { public string HopefullyAString { get; set; } } class Payload { public Maybe<string> HopefullyAString { get; set; } } async Task<Payload> Normalize(PayloadDto dto) => return Task.FromResult(new Payload { HopefullyAString = Maybe.Of(dto.HopefullyAString) }); void LogValue(Payload payload) { var length = payload.HopefullyAString.MapReturn(s => s.Length, 0); loger.Debug(\"Payload length: {length}\", length); } async Task RequestFromApi() { await client.FetchFromApi() .ContinueWith(Normalize) .ContinueWith(LogValue); } Now, you might be thinking, Sure, but we could get the same effect by just supplying a default value when we deserialize the data. That‚Äôs true, you could! Here, for example, you could just normalize it to an empty string. And of course, if just supplying a default value at the API boundary is the right move, you can still do that. Maybe is another tool in your toolbox, not something you‚Äôre obligated to use everywhere you can. However, sometimes there isn‚Äôt a single correct default value to use at the API boundary. You might need to handle that missing data in a variety of ways throughout your application. For example, what if you need to treat ‚Äúno value‚Äù distinctly from ‚Äúthere‚Äôs a value present, and it‚Äôs an empty string‚Äù? That‚Äôs where Maybe comes in handy. Result Another common scenario we find ourselves in is dealing with operations which might fail. The most common pattern in .NET for dealing with this: exceptions . There are major problems with exception, especially around reusability and composability. Exceptions are unpredictable: you can‚Äôt know whether a given function invocation is going to throw an exception until runtime as someone calling the function. No big deal if it‚Äôs a small application and one person wrote all the code, but with even a few thousand lines of code or two developers, it‚Äôs very easy to miss that. And then this happens: // in one part of the codebase object GetMeAValue(sring url) { if (IsMalformed(url)) { throw new Exception($\"The url `{url}` is malformed!\"); } // do something else to load data from the URL return data; } string RenderHtml(object toRender) { // if toRender can't generate valid HTML, throw Error(\"invalid HTML\"); // if it can, theRenderedHTML; } void WriteOutput(string html) { // I/O } // somewhere else in the codebase -- throws an exception var badUrl = \"http:/www.google.com\"; // missing a slash var response = GetMeAValue(badUrl); // throws here // we never get here, but it could throw too var htmlForPage = RenderHtml(value); // so we definitely can't get here safely WriteOutput(htmlForPage); Notice: there‚Äôs no way for the caller to know that the function will throw. Perhaps you‚Äôre very disciplined and write good docstrings for every function ‚Äì and moreover, perhaps everyone‚Äôs editor shows it to them and they pay attention to that briefly-available popover. More likely, though, this exception throws at runtime and probably as a result of user-entered data ‚Äì and then you‚Äôre chasing down the problem through error logs. More, if you do want to account for the reality that any function anywhere in C‚ôØ might actually throw, you‚Äôre going to write something like this: try { var badUrl = \"http:/www.google.com\"; // missing a slash var response = GetMeAValue(badUrl); // throws here // we never get here, but it could throw too var htmlForPage = RenderHtml(value); // so we definitely can't get here safely WriteOutput(htmlForPage); } catch(Exception exn) { HandleErr(exn); } This kind of universal boilerplate works against the Don't Repeat Yourself principle, and C‚ôØ can‚Äôt help you here! There's no type signatures to say ‚ÄúThis throws an exception!‚Äù Instead, we can use a Result to get us a container type, much like Maybe , to let us deal with this scenario. A Result is either an Ok wrapping around a value (like Just does) or an Err wrapping around some type defining what went wrong (unlike Nothing , which has no contents). Result<Payload, string> GetMeAValue(string url) { if (IsMalformed(url)) { return Result<Payload, string>.Err($\"The url '{url}' is malformed\"); } // do something else to load data from the url return Result.Ok(data); } Result<string, string> RenderHtml(string toRender) { // if toRender can't generate valid HTML, return Err(\"invalid HTML\"); // if it can, return Ok(theRenderedHTML); } void WriteOutput(string html) { } // somewhere else in the codebase -- no exception this time! var badUrl = \"http:/www.google.com\"; // missing a slash // value = Err(The url '${http:/www.google.com}' is malformed) var value = GetMeAValue(badUrl); // htmlForPage = the same error! or, if it was Ok, could be a different // `Err` (because of how `andThen` works). var htmlForPage = value.AndThen(RenderHtml); value.Match( ok: html => WriteOutput(html.UnwrapOr(string.Empty)); err: reason => Alert($\"Something went seriously wrong here! {reason}\"); ) When we have a Result instance, we can perform tons of operations on whether it‚Äôs Ok or Err , just as we could with a Just and Nothing , until we need the value. Maybe that‚Äôs right away. Maybe we don‚Äôt need it until somewhere else deep in our application! Either way, we can deal with it easily enough, and have type safety throughout!"
  },
  "articles/manual.html": {
    "href": "articles/manual.html",
    "title": "Overview | True Myth",
    "keywords": "Overview True Myth provides idiomatic, type-safe wrappers and helper functions to help help you with two extremely common cases in programming: not having a value having a result where you need to deal with either success or failure You could implement all of these yourself ‚Äì it's not hard! ‚Äì but it's much easier to just have one extremely well-tested library you can use everywhere to solve this problem once and for all. Comparison to other Libraries TrueMyth TypeScript This TrueMyth library is derived from the original TrueMyth , which was designed for TypeScript. It was initially ported, but then later was redesigned somewhat to be more idiomatic for C‚ôØ. Below is a mapping of functions; you may find it useful to be able to link back to the documentation of the original library in cases where this documentation is lacking. Maybe Mapping TypeScript C‚ôØ all<T>(...maybes: T): All<T> Maybe<IEnumerable<T>> Maybe.All<T>(params Maybe<T>[] maybes) and<T,U>(andMaybe: Maybe<U>, maybe: Maybe<T>): Maybe<U> Maybe<U> Maybe<T>.And<U>(Maybe<U> andMaybe) andThen<T,U>(thenFn: function, maybe: Maybe<T>): Maybe<U> Maybe<U> Maybe<T>.AndThen<U>(Func<TValue, Maybe<U>> bindFn) ap<T,U>(maybeFn: Maybe<function>, maybe: Maybe<T>): Maybe<U> No equivalent equals<T>(mb: Maybe<T>, ma: Maybe<T>): boolean bool Object.Equals(object obj) find<T>(predicate: Result<T,any>): Maybe<T> Maybe<IEnumerable<T>> Maybe.MaybeFind<T>(this IEnumerable<T> list, Func<T,bool> predicate) fromResult<T>(result: Result<T,any>): Maybe<T> Maybe<T> Maybe.From<T,E>(Result<T,E> result) get<T,K>(key: K, maybeObj: Maybe<T>): Maybe<Required<T>[K]> Maybe<T> Maybe.MaybeGet<K,V>(this ICollection<KeyValuePair<T,K>> collection, T key) head<T>(array: Array<T + null + undefined>): Maybe<T> Maybe<T> Maybe.MaybeFirst<T>(this IEnumerable<T> list) isInstance<T>(item: any): boolean Not applicable isJust<T>(maybe: Maybe<T>) bool Maybe<T>.IsJust isNothing<T>(maybe: Maybe<T>) bool Maybe<T>.IsNothing just<T>(value?: T + null): Maybe<T> No equivalent. last<T>(array: Array<T + null + undefined>): Maybe<T> Maybe<T> Maybe.MaybeLast<T>(this IEnumerable<T> list) map<T,U>(mapFn: function, maybe: Maybe<T>): Maybe<U> Maybe<U> Maybe<T>.Map<U>(Func<T,U> mapFn) mapOr<T,U>(orU: U, mapFn: function, maybe: Maybe<T>): U U Maybe<T>.MapReturn<U>(Func<T,U> mapFn, U defaultValue) mapOrElse<T,U>(orElseFn: function, mapFn: function, maybe: Maybe<T>): U See match / Maybe<T>.Match<U> match<T,A>(matcher: Matcher<T,A>, maybe: Maybe<T>): A U Maybe<T>.Match<U>(Func<T,U> just, Func<T> nothing) nothing<T>(_?: undefined + null): Maybe<T> Maybe<T> Maybe<T>.Nothing of<T>(value?: T + null): Maybe<T> Maybe.Of(T value) or<T>(defaultMaybe: Maybe<T>, maybe: Maybe<T>): Maybe<T> Maybe<T> Maybe<T>.Or(Maybe<T> maybe) orElse<T>(elseFn: function, maybe: Maybe<T>): Maybe<T> Maybe<T> Maybe<T>.OrElse(Func<Maybe<T>> elseFn) property<T,K>(key: K, obj: T):Maybe<Required<T>[K]> See get / Maybe.MaybeGet toOkOrElse<T,E>(elseFn: function, maybe: Maybe<T>): Result<T,E> Result<T,E> Maybe<T>.ToResult<E>(Func<E> errFn) toOkOrErr<T,E>(error: E, maybe: Maybe<T>): Result<T,E> Result<T,E> Maybe<T>.ToResult<E>(E error) toString<T>(maybe: Maybe<T>): string string Object.ToString() tuple<T>(maybes: Maybe<T>): Maybe<[T]> Maybe<(T,U)> Maybe.MaybeAll<T,U>(this Tuple<Maybe<T>, Maybe<U>> tuple) and similarly for up to 4-tuples unsafelyUnwrap<T>(maybe: Maybe<T>): T T Maybe<T>.UnsafelyUnwrap() unwrapOr<T>(defaultValue: T, maybe: Maybe<T>): T T Maybe<T>.UnwrapOr(T defaultValue) unwrapOrElse<T>(orElseFn: function, maybe: Maybe<T>): T T Maybe<T>.UnwrapOrElse(Func<T> elseFn) Result Mapping TypeScript C‚ôØ and<T,U,E>(andResult: Result<U,E>, result: Result<T,E>): Result<U,E> Result<U,E> Result<T,E>.And<U>(Result<UValue,TError> andResult) andThen<T,U,E>(thenFn: function, result: Result<T,E>): Result<U,E> Result<U,E> Result<T,E>.AndThen<U>(Func<TValue, UValue> bindFn) ap<T,U,E>(resultFn: Result<function, E>, result: Result<T,E>): Result<U,E> No equivalent. equals<T,E>(resultB: Result<T,E>, resultA: Result<T,E>): boolean bool Object.Equals(object) err<T,E>(error: E): Result<T, E> Result<T,E> Result<T,E>.Err(E error) err<T,E>(): Result<T,E> No equivalent. fromMaybe<T,E>(errValue: E, maybe: Maybe<T>): Result<T,E> Result<T,E> Result.From<T,E>(Maybe<T> maybe, E error) isErr<T,E>(result: Result<T,E>): boolean bool Result<T,E>.IsErr isInstance<T,E>(item: any): boolean Not applicable. isOk<T,E>(result: Result<T,E>): boolean bool Result<T,E>.IsOk map<T,U,E>(mapFn: function, result: Result<T,E>): Result<U,E> Result<U,E> Result<T,E>.Map<U>(Func<T,U> mapFn) mapErr<T,E,F>(mapErrFn: function, result: Result<T,E>): Result<T,F> Result<T,F> Result<T,E>.MapErr<F>(Func<E,F> mappErrFn) mapOr<T,U,E>(orU: U, mapFn: function, result: Result<T,E>): U U Result<T,E>.MapReturn(Func<T,U> mapFn, U defaultValue) mapOrElse<T,U,E>(orElseFn: function, mapFn, function, result: Result<T,E>): U See match / Result<T,E>.Match<U> match<T,E,A>(matcher: Matcher<T,E,A>, result: Result<T,E>): A U Result<T,E>.Match<U>(Func<T,U> okFn, Func<E,U> errFn) ok<T,E>() : Result<Unit,E> No equivalent. ok<T,E>(T value): Result<T,E> Result<T,E>.Ok(T value) or<T,E,F>(defaultResult: Result<T,F>, result: Result<T,E>): Result<T,F> Result<T,F> Result<T,E>.Or<F>(Result<T,F> defaultResult) orElse<T,E,F>(elseFn: function, result: Result<T,E>): Result<T,F> Result<T,F> Result<T,E>.OrElse(Func<Result<T,F>> elseFn) toMaybe<T>(result: Result<T, any>): Maybe<T> Maybe<T> Result<T,E>.ToMaybe() toString<T,E>(result: Result<T,E>): string string Object.ToString() tryOr<T,E>(error: E, callback: function): Result<T,E> Result<T,E> Result.Try<T,E>(Func<T> tryFn, E error) tryOrElse<T,E>(onError: function, callback: function): Result<T,E> Result<T,E> Result.Try(Func<T> tryFn, Func<E> errFn) unsafelyUnwrap<T,E>(result: Result<T,E>): T T Result<T,E>.UnsafelyUnwrap() unsafelyUnwrapErr<T,E>(result: Result<T,E>): E E Result<T,E>.UnsafelyUnwrapErr() unwrapOr<T,E>(defaultValue: T, result: Result<T,E>): T T Result<T,E>.Unwrap(T defaultValue) unwrapOrElse<T,E>(orElseFn: function, result: Result<T,E>) T Result<T,E>.Unwrap(Func<E,T> errFn)"
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started | True Myth",
    "keywords": "Getting Started Prerequisites & Dependencies This assumes you have a working .NET environment, including access to nuget.org. True Myth targets the .NET Framework v4.6.1 (and higher) and .NET Standard 2.0 (and higher). There are no other dependencies. Installation Install the TrueMyth nuget package using your choice of package manager. Usage You'll want to add a using statement for the TrueMyth namespace. This will make the Result<TValue,TError> , Maybe<TValue> , and associated utility methods available in your compilation unit. Simple Example I've tried to make this as complete an example as reasonably possible without making it so big that it takes more than a minute or two to read. using Microsoft.AspNetCore.Mvc; using TrueMyth; namespace MyWebApp { /* interface IModelRepository { Result<Maybe<Model>, string> GetModel(int id); } */ public class AspNetController : Controller { private readonly IModelRepository _modelRepository; public AspNetController(IModelRepository modelRepository) { _modelRepository = modelRepository; } public IActionResult GetResource(int id) { return _modelRepository.GetModel(id) .Match( err: err => StatusCode(500), // val is a Maybe<Model> ok: val => val.Match( just: model => Json(model), nothing: () => NotFound())); } } }"
  },
  "api/TrueMyth.Unsafe.html": {
    "href": "api/TrueMyth.Unsafe.html",
    "title": "Namespace TrueMyth.Unsafe | True Myth",
    "keywords": "Namespace TrueMyth.Unsafe Classes UnsafeExtensions Extensions to the Maybe<TValue> and Result<TValue, TError> implementations; the use of these methods is discouraged by organizing them this way."
  },
  "api/TrueMyth.Result.html": {
    "href": "api/TrueMyth.Result.html",
    "title": "Class Result | True Myth",
    "keywords": "Class Result A static class that provides factory and extension methods for Result<TValue, TError> . Inheritance System.Object Result Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TrueMyth Assembly : TrueMyth.dll Syntax public static class Result Methods | Improve this Doc View Source From<T, TError>(Maybe<T>, TError) Convenience method to facilitate invoking static Result<TValue,TError> methods without type parameters. Declaration public static Result<T, TError> From<T, TError>(Maybe<T> maybe, TError error) Parameters Type Name Description Maybe <T> maybe TError error Returns Type Description Result <T, TError> Type Parameters Name Description T TError | Improve this Doc View Source Try<TValue, TError>(Func<TValue>, TError) Execute the provided callback, wrapping the return value in an Result.Ok or Result.Err if there is an exception. Declaration public static Result<TValue, TError> Try<TValue, TError>(Func<TValue> fn, TError error) Parameters Type Name Description System.Func <TValue> fn TError error Returns Type Description Result <TValue, TError> Type Parameters Name Description TValue TError Examples var aSuccessfulOperation = () => 2 + 2; var anOkResult = Result.Try(aSuccessfulOperation, \"Oh no!\"); // Ok<int,string>[4] var aThrowingOperation = () => throw new Exception(\"Bummer\"); var anErrResult = Result.Try(aThrowingOperation, \"Oh no!\"); // Err<int,string>[Oh no!] | Improve this Doc View Source Try<TValue, TError>(Func<TValue>, Func<TError>) Execute the provided callback, wrapping the return value in an Result.Ok . If there is an exception, wrap the result of errFn in a Result.Err . Declaration public static Result<TValue, TError> Try<TValue, TError>(Func<TValue> fn, Func<TError> errFn) Parameters Type Name Description System.Func <TValue> fn System.Func <TError> errFn Returns Type Description Result <TValue, TError> Type Parameters Name Description TValue TError Examples var aSuccessfulOperation = () => 2 + 2; var anOkResult = Result.Try(aSuccessfulOperation, () => string.Empty); // Ok<int,string>[4] var aThrowingOperation () => throw new Exception(\"Bummer\"); var anErrResult = Result.Try(aThrowingOperation, (exn) => exn.Message); // Err<int,string>[Bummer]"
  },
  "api/TrueMyth.Maybe.html": {
    "href": "api/TrueMyth.Maybe.html",
    "title": "Class Maybe | True Myth",
    "keywords": "Class Maybe A static class that provides factory and extension methods for Maybe<TValue> . Inheritance System.Object Maybe Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TrueMyth Assembly : TrueMyth.dll Syntax public static class Maybe Methods | Improve this Doc View Source All<T>(Maybe<T>[]) A convenience method that has the same behavior as AsMaybe<T>(IEnumerable<Maybe<T>>) . Declaration public static Maybe<IEnumerable<T>> All<T>(params Maybe<T>[] maybes) Parameters Type Name Description Maybe <T>[] maybes Returns Type Description Maybe < System.Collections.Generic.IEnumerable <T>> Type Parameters Name Description T | Improve this Doc View Source AsMaybe<T>(IEnumerable<Maybe<T>>) Convert the arguments to a single Maybe<IEnumerable<T>> , but only if all elements of the list are Just . If any of the elements of the list are actually Nothing , then the result will also be a Nothing . Declaration public static Maybe<IEnumerable<T>> AsMaybe<T>(this IEnumerable<Maybe<T>> maybes) Parameters Type Name Description System.Collections.Generic.IEnumerable < Maybe <T>> maybes A list of Maybe<T> s to aggregate. Returns Type Description Maybe < System.Collections.Generic.IEnumerable <T>> A single Maybe<IEnumerable<T>> . Type Parameters Name Description T The type represented by the maybe parameters. | Improve this Doc View Source AsMaybe<T, U>(Tuple<Maybe<T>, Maybe<U>>) Given a tuple of Maybe s, return a Maybe of the tuple types. This behaves similarly to AsMaybe<T>(IEnumerable<Maybe<T>>) . Declaration public static Maybe<(T, U)> AsMaybe<T, U>(this Tuple<Maybe<T>, Maybe<U>> tuple) Parameters Type Name Description System.Tuple < Maybe <T>, Maybe <U>> tuple Returns Type Description Maybe < System.ValueTuple <T, U>> Type Parameters Name Description T Type of the value represented by the first Maybe in the tuple. U Type of the value reprsented by the second Maybe in the tuple. | Improve this Doc View Source AsMaybe<T, U, V>(Tuple<Maybe<T>, Maybe<U>, Maybe<V>>) Similar to AsMaybe<T, U>(Tuple<Maybe<T>, Maybe<U>>) , but with a 3-tuple. Declaration public static Maybe<(T, U, V)> AsMaybe<T, U, V>(this Tuple<Maybe<T>, Maybe<U>, Maybe<V>> tuple) Parameters Type Name Description System.Tuple < Maybe <T>, Maybe <U>, Maybe <V>> tuple Returns Type Description Maybe < System.ValueTuple <T, U, V>> Type Parameters Name Description T U V | Improve this Doc View Source AsMaybe<T, U, V, W>(Tuple<Maybe<T>, Maybe<U>, Maybe<V>, Maybe<W>>) Similar to AsMaybe<T, U>(Tuple<Maybe<T>, Maybe<U>>) , but with a 4-tuple. Declaration public static Maybe<(T, U, V, W)> AsMaybe<T, U, V, W>(this Tuple<Maybe<T>, Maybe<U>, Maybe<V>, Maybe<W>> tuple) Parameters Type Name Description System.Tuple < Maybe <T>, Maybe <U>, Maybe <V>, Maybe <W>> tuple Returns Type Description Maybe < System.ValueTuple <T, U, V, W>> Type Parameters Name Description T U V W | Improve this Doc View Source AsNullable<T>(Maybe<T>) Converts a Maybe<T> to a System.Nullable<T> . If this is a Just , then the result will be a Nullable<T> where HasValue is true and whose value is the value of the maybe. If this is a Nothing , then the result will be a Nullable<T> where HasValue is false and whose value is null . Declaration public static T? AsNullable<T>(this Maybe<T> maybe) where T : struct Parameters Type Name Description Maybe <T> maybe Returns Type Description System.Nullable <T> Type Parameters Name Description T | Improve this Doc View Source From<T>(Nullable<T>) Creates a new Maybe<T> from a System.Nullable<T> . If the Nullable<T> is null , then the resulting maybe will be a Nothing ; otherwise, the resulting maybe will be a Just and its value will be the value of the Nullable<T> . Declaration public static Maybe<T> From<T>(T? nullable) where T : struct Parameters Type Name Description System.Nullable <T> nullable Returns Type Description Maybe <T> Type Parameters Name Description T | Improve this Doc View Source From<T, TError>(Result<T, TError>) This method facilitates converting from a Result<TValue, TError> to a Maybe<TValue> . The difference between this and Of<T>(T) is that the resulting Mabye is a Maybe<T> rather than a Maybe<Result<T,TError>> . If the provided Result is actually an error result (e.g., result.IsErr == true ), then the returned Maybe will be a Nothing . Declaration public static Maybe<T> From<T, TError>(Result<T, TError> result) Parameters Type Name Description Result <T, TError> result The Result<T,TError> Returns Type Description Maybe <T> A Maybe<T> representing either a Just T or Nothing , depending on the provided result . Type Parameters Name Description T The value type of result . TError The error type of result . | Improve this Doc View Source MaybeFind<T>(IEnumerable<T>, Func<T, Boolean>) A safe method for finding elements of a list for which the predicate returns true . This method guarantees a valid Maybe<T> result; it never returns null and never throws an exception. Declaration public static Maybe<IEnumerable<T>> MaybeFind<T>(this IEnumerable<T> list, Func<T, bool> predicate) Parameters Type Name Description System.Collections.Generic.IEnumerable <T> list The list to search. System.Func <T, System.Boolean > predicate A predicate function to execute on each element. Returns Type Description Maybe < System.Collections.Generic.IEnumerable <T>> Type Parameters Name Description T The type of the list elements and of the value of the resulting Maybe<T> instances. | Improve this Doc View Source MaybeFirst<TValue>(IEnumerable<TValue>) Safely get the first item from a list, returning Just the first item if the array has at least one item in it, or Nothing if it is empty. Declaration public static Maybe<TValue> MaybeFirst<TValue>(this IEnumerable<TValue> list) Parameters Type Name Description System.Collections.Generic.IEnumerable <TValue> list The array from which to get the first item. Returns Type Description Maybe <TValue> A Maybe<TValue> of the first item of the list (which might be Nothing if the list is empty). Type Parameters Name Description TValue The type of the items of list . | Improve this Doc View Source MaybeGet<TKey, TValue>(ICollection<KeyValuePair<TKey, TValue>>, TKey) A safe way to retrieve values from key-value collections (like System.Collections.Generic.Dictionary`2 ). If the requested key does not exist, a Maybe<TValue;>.Nothing is returned. Otherwise, a Maybe<TValue> is constructed from the value associated with key . Declaration public static Maybe<TValue> MaybeGet<TKey, TValue>(this ICollection<KeyValuePair<TKey, TValue>> collection, TKey key) Parameters Type Name Description System.Collections.Generic.ICollection < System.Collections.Generic.KeyValuePair <TKey, TValue>> collection The key-value collection from which to retrieve values. Will most often be a Dictionary<TKey,TValue> . TKey key The key to use to retrieve a value. Returns Type Description Maybe <TValue> A Maybe<TValue> .Nothing if no value exists associated with the given key; a Just otherwise. Type Parameters Name Description TKey The type of key . TValue The type of the value stored in collection as well as the type stored by the resulting Maybe<TValue> . | Improve this Doc View Source MaybeLast<TValue>(IEnumerable<TValue>) Safely get the last item from a list, returning Just the last item if the array has at least one item in it, or Nothing if it is empty. Declaration public static Maybe<TValue> MaybeLast<TValue>(this IEnumerable<TValue> list) Parameters Type Name Description System.Collections.Generic.IEnumerable <TValue> list The array from which to get the last item. Returns Type Description Maybe <TValue> A Maybe<TValue> of the last item of the list (which might be Nothing if the list is empty). Type Parameters Name Description TValue The type of the items of list . | Improve this Doc View Source Of<T>(T) This method is a convenience method that is equivalent to Of(TValue) . It constructs a Maybe<T> from the provided value. This method can take advantage of type inference where Of(TValue) cannot. Declaration public static Maybe<T> Of<T>(T value) Parameters Type Name Description T value The value to be held by the resulting Maybe<T> .false If value is null , the resulting Maybe<T> will be a Nothing . Returns Type Description Maybe <T> A Maybe<T> instance representing value . Type Parameters Name Description T Any type suported by C‚ôØ. | Improve this Doc View Source Of<T>(Nullable<T>) This overload, specifically for Nullable<T> , behaves identically to Of<T>(T) . Declaration public static Maybe<T> Of<T>(T? nullable) where T : struct Parameters Type Name Description System.Nullable <T> nullable Returns Type Description Maybe <T> Type Parameters Name Description T"
  },
  "api/TrueMyth.Result-2.html": {
    "href": "api/TrueMyth.Result-2.html",
    "title": "Class Result<TValue, TError> | True Myth",
    "keywords": "Class Result<TValue, TError> A Result<TValue,TError> is a type representing the value result of an operation which may fail, with a successful value type of TValue or an error type of TError (pun intended!). If the value is present, it is Ok , and if absent, it's Err . There are several ways to check if a Result is Ok or Err , but the most direct and explicit are the IsOk and IsErr properties. This provides a type-safe container for dealing with the possibility that an error occurred, without needing to scatter try / catch blocks throughout your codebase. This has two major advantages: You know when an item may have a failure case, unlike cases in which exceptions are thrown (which may be thrown from any function with no warning and no help from the type system). The error scenario is a first-class citizen, and the provided helper functions and methods allow you to deal with the type in much the same way as you might an array ‚Äî transforming values if present, or dealing with errors instead of necessary. Inheritance System.Object Result<TValue, TError> Implements System.IComparable System.IComparable < Result <TValue, TError>> Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : TrueMyth Assembly : TrueMyth.dll Syntax public sealed class Result<TValue, TError> : IComparable, IComparable<Result<TValue, TError>> Type Parameters Name Description TValue The value type for Ok values. TError The value type for Err values. Examples To make this concrete, let's look at an example.see Without TrueMyth, you might have the following C‚ôØ: int MightSucceed(bool doesSucceed) { if (!doesSucceed) throw new Exception(\"hey guess what? it didn't succeed.see\"); return 42; } int Main(string[] args) { var doubleTheAnswer = MightSucceed(true) * 2; Console.WriteLine(doubleTheAnswer); // 84; this is fine var doubleAnError = MightSucceed(false) * 2; Console.Write(doubleAnError); // oops! we never even get here. } If we wanted to handle that error, we'd need to first of all know that the function could throw an error. Assuming we knew that ‚Äî progbably we'd figure it out via painful discovery at runtime ‚Äî then we'd need to wrap it up in a try / catch block: int Main(string[] args) { try { var doubleTheAnswer = MightSucceed(true) * 2; Console.WriteLine(doubleTheAnswer); // 84; this is fine var doubleAnError = MightSucceed(false) * 2; Console.WriteLine(doubleAnError); } catch(Exception exn) { Console.WriteLine(exn.Message); } } This is a pain to work with! The next thing we might try is returning an error code and mutating an object passed in (e.g. bool TryMightSucceed(bool doesSucceed, out int result) ). But that has a few problems: You have to mutate an object. This doesn't work for simple items like numbers, and it can also be pretty unexpected behavior at times ‚Äî you want to know when something is going to change, and mutating freely throughout a library or application makes that impossible. You have to make sure to actually check the return code to make sure it's valid. In theory, we're all disciplined enough to always do that. In practice, we often end up reasoning, Well, this particular call can never fail... (but of course, it probably can, just not in the way we expect). We don't have a good way to return a reason for the error. We end up needing to introduce another parameter, designed to be mutated, to make sure that's possible. Even if you go to all the trouble of doing all that, you need to make sure ‚Äî every time ‚Äî that you use only the error value if the return code specified an error, and only the success value if the return code specified that it succeeded. Our way out is Result<TValue,TError> . It lets us just return one thing from a function, which encapsulates the possiblility of failure in the very thing we return. We get: Here's what that same example from above would look like using Result : Result<int,string> MightSucceed(bool doesSucceed) => doesSucceed ? Result<int,string>.Ok(42) : Result<int,string>.Err(\"something went wrong!\"); int Main(string[] args) { int Double(int x) = x * 2; var doubleTheAnswer = MightSucceed(true).Select(Double); Console.WriteLine(doubleTheAnswer); // Ok<int,string>[84] var doubleAnErr = MightSucceed(false).Select(Double); Console.WriteLine(doubleAnErr); // Err<int,string>[something went wrong] } Note that if we tried to call MightSucceed(true)*2 here, we'd get a type error ‚Äî this wouldn't make it past the compile step. Properties | Improve this Doc View Source IsErr This is merely the reverse of IsOk ; if this is an Err , then the property is true . Declaration public bool IsErr { get; } Property Value Type Description System.Boolean | Improve this Doc View Source IsOk Is this Result an Ok ? This property is true if so. Declaration public bool IsOk { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source And<UValue>(Result<UValue, TError>) You can think of this like a short-circuiting logical \"and\" operation on a Result type. If result is Ok, then the result is the andResult . If result is Err, the result is the Err. This is useful when you have another Result value you want to provide if and only if you have an Ok ‚Äì that is, when you need to make sure that if you Err, whatever else you're handing a Result to also gets that Err. Notice that, unlike in Map<UValue>(Func<TValue, UValue>) or its variants, the original result is not involved in constructing the new Result. Declaration public Result<UValue, TError> And<UValue>(Result<UValue, TError> andResult) Parameters Type Name Description Result <UValue, TError> andResult Result returned if this is an Ok. Returns Type Description Result <UValue, TError> Type Parameters Name Description UValue | Improve this Doc View Source AndThen<UValue>(Func<TValue, Result<UValue, TError>>) Apply a function to the wrapped value if Ok and return a new Ok containing the resulting value; or if it is Err return it unmodified. This differs from Map<UValue>(Func<TValue, UValue>) in that thenFn returns another Result . You can use andThen to combine two functions which both create a Result from an unwrapped type. Declaration public Result<UValue, TError> AndThen<UValue>(Func<TValue, Result<UValue, TError>> bindFn) Parameters Type Name Description System.Func <TValue, Result <UValue, TError>> bindFn Function that returns Result if this is an Ok. Returns Type Description Result <UValue, TError> Type Parameters Name Description UValue Ok value type of result of thenFn . | Improve this Doc View Source CompareTo(Object) Declaration public int CompareTo(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Int32 | Improve this Doc View Source CompareTo(Result<TValue, TError>) Declaration public int CompareTo(Result<TValue, TError> otherResult) Parameters Type Name Description Result <TValue, TError> otherResult Returns Type Description System.Int32 | Improve this Doc View Source Equals(Object) Declaration public override bool Equals(object o) Parameters Type Name Description System.Object o Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this Doc View Source Err(TError) A factory method for creating Err Result instances. Declaration public static Result<TValue, TError> Err(TError err) Parameters Type Name Description TError err The error value wrapped by the Result Returns Type Description Result <TValue, TError> | Improve this Doc View Source From(Maybe<TValue>, TError) Transform a Maybe<T> into a Result<T,TError> . If the Maybe is a Just , its value will be wrapped in the Ok variant; if it is a Nothing the errValue will be wrapped in the Err variant. Declaration public static Result<TValue, TError> From(Maybe<TValue> maybe, TError errValue) Parameters Type Name Description Maybe <TValue> maybe TError errValue Returns Type Description Result <TValue, TError> | Improve this Doc View Source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this Doc View Source Map<UValue>(Func<TValue, UValue>) Map over a Result instance: apply the function to the wrapped value if the instance is Ok, and return the wrapped error value wrapped as a new Err of the correct type (Result<UValue, TError>) if the instance is Err. Result.Select works a lot like it does for System.Collections.Generic.IEnumerable<T> , but with one important difference. Both Result and IEnumerable are containers for other kinds of items, but where IEnumerable > has 0 to n items, a Result always has exactly one item, which is either a success or an error instance. Where IEnumerable.Select will apply the mapping function to every item in the enumeration (if there are any), Result.Select will only apply the mapping function to the (single) element if an Ok instance, if there is one. If you have no items in an array of numbers named foo and call foo.Select(x => x + 1), you'll still some have an array with nothing in it. But if you have any items in the array ( {2, 3} ), and you call foo.Select(x => x + 1) on it, you'll get a new array with each of those items inside the array \"container\" transformed ( {3, 4} ). With Result.Select , the Err variant is treated by the map function kind of the same way as the empty array case: it's just ignored, and you get back a new Result that is still just the same Err instance. But if you have an Ok variant, the map function is applied to it, and you get back a new Result with the value transformed, and still wrapped in an Ok. Declaration public Result<UValue, TError> Map<UValue>(Func<TValue, UValue> mapFn) Parameters Type Name Description System.Func <TValue, UValue> mapFn Mapping function applied to Ok value. Returns Type Description Result <UValue, TError> Type Parameters Name Description UValue Destination value type resulting from the mapping function. Examples long Double(int n) => n * 2; var anOk = Result<int,string>.Ok(12); var mappedOk = anOk.Select(Double); Console.WriteLine(mappedOk.ToString()); // Ok<long,string>[12] var anErr = Result<int,string>.Err(\"error\"); var mappedErr = anErr.Select(Double); Console.WriteLine(mappedErr.ToString()); // Err<long,string>[error] | Improve this Doc View Source MapErr<UError>(Func<TError, UError>) Map over a Result , exactly as in map, but operating on the value wrapped in an Err instead of the value wrapped in the Ok. This is handy for when you need to line up a bunch of different types of errors, or if you need an error of one shape to be in a different shape to use somewhere else in your codebase. Declaration public Result<TValue, UError> MapErr<UError>(Func<TError, UError> mapFn) Parameters Type Name Description System.Func <TError, UError> mapFn Mapping function to apply to error wrapped in Err Result . Returns Type Description Result <TValue, UError> Type Parameters Name Description UError Mapped error type resulting from mapping function. | Improve this Doc View Source MapReturn<UValue>(Func<TValue, UValue>, UValue) Map over a Result instance as in map and get out the value if result is an Ok, or return a default value if result is an Err. Declaration public UValue MapReturn<UValue>(Func<TValue, UValue> mapFn, UValue defaultValue) Parameters Type Name Description System.Func <TValue, UValue> mapFn Mapping function to apply to wrapped Ok value. UValue defaultValue Fallback value to return if this is an Err. Returns Type Description UValue Type Parameters Name Description UValue Destination type resulting from mapping function mapFn . | Improve this Doc View Source Match(Action<TValue>, Action<TError>) Provides similar functionality as Match<T>(Func<TValue, T>, Func<TError, T>) , but with no return type. Declaration public void Match(Action<TValue> ok, Action<TError> err) Parameters Type Name Description System.Action <TValue> ok System.Action <TError> err | Improve this Doc View Source Match<T>(Func<TValue, T>, Func<TError, T>) Performs the same basic functionality as UnwrapOrElse(Func<TError, TValue>) , but instead of simply unwrapping the value if it is Ok and applying a function to generate the same type if it is Err, lets you supply functions which may transform the wrapped type if it is Ok or get a default value for Err. This is kind of like a poor man's version of pattern matching, for which C‚ôØ has only limited support. Declaration public T Match<T>(Func<TValue, T> ok, Func<TError, T> err) Parameters Type Name Description System.Func <TValue, T> ok System.Func <TError, T> err Returns Type Description T Type Parameters Name Description T Examples Instead of code like this: var anOk = Result<int,string>.Ok(42); int value; switch(anOk.IsOk) { true: value = anOk.UnsafelyUnwrap() * 2; break; false: value = anOk.UnsafelyUnwrapErr().Length + 2; break; } Console.WriteLine(value); // 84 we can write code like this: var anOk = Result<int,string>.Ok(42); var value = anOk.Match( ok: val => val * 2, err: errval => errval.Length + 2; ); Console.WriteLine(value); // 84 | Improve this Doc View Source Ok(TValue) A factory method for creating Ok Result instances. note null is allowed by the type signature, but it is highly recommended to use Maybe<TValue> rather than a null as a result. Declaration public static Result<TValue, TError> Ok(TValue value) Parameters Type Name Description TValue value The success value wrapped by the Result Returns Type Description Result <TValue, TError> | Improve this Doc View Source Or<UError>(Result<TValue, UError>) Provide a fallback for a given Result . Behaves like a logical or: if the result value is an Ok, returns that result; otherwise, returns the defaultResult value. This is useful when you want to make sure that something which takes a Result always ends up getting an Ok variant, by supplying a default value for the case that you currently have an Err. Declaration public Result<TValue, UError> Or<UError>(Result<TValue, UError> defaultResult) Parameters Type Name Description Result <TValue, UError> defaultResult Returns Type Description Result <TValue, UError> Type Parameters Name Description UError | Improve this Doc View Source OrElse<UError>(Func<Result<TValue, UError>>) Like Or<UError>(Result<TValue, UError>) , but using a function to construct the alternative Result. Sometimes you need to perform an operation using other data in the environment to construct the fallback value. In these situations, you can pass a function (which may be a closure) as the elseFn to generate the fallback Result<TValue,TError>. It can then transform the data in the Err to something usable as an Ok, or generate a new Err instance as appropriate. Useful for transforming failures to usable data. Declaration public Result<TValue, UError> OrElse<UError>(Func<Result<TValue, UError>> elseFn) Parameters Type Name Description System.Func < Result <TValue, UError>> elseFn Returns Type Description Result <TValue, UError> Type Parameters Name Description UError | Improve this Doc View Source Select<UValue>(Func<TValue, UValue>) An alias for Map<UValue>(Func<TValue, UValue>) . Declaration public Result<UValue, TError> Select<UValue>(Func<TValue, UValue> mapFn) Parameters Type Name Description System.Func <TValue, UValue> mapFn Returns Type Description Result <UValue, TError> Type Parameters Name Description UValue | Improve this Doc View Source SelectErr<UError>(Func<TError, UError>) An alias for MapErr<UError>(Func<TError, UError>) Declaration public Result<TValue, UError> SelectErr<UError>(Func<TError, UError> mapFn) Parameters Type Name Description System.Func <TError, UError> mapFn Returns Type Description Result <TValue, UError> Type Parameters Name Description UError | Improve this Doc View Source SelectMany<UValue>(Func<TValue, Result<UValue, TError>>) An alias for AndThen<UValue>(Func<TValue, Result<UValue, TError>>) . Declaration public Result<UValue, TError> SelectMany<UValue>(Func<TValue, Result<UValue, TError>> bindFn) Parameters Type Name Description System.Func <TValue, Result <UValue, TError>> bindFn Returns Type Description Result <UValue, TError> Type Parameters Name Description UValue | Improve this Doc View Source ToMaybe() Convert a Result to a Maybe<TValue> . The converted type will be Just if the Result is Ok or Nothing if the Result is Err; the wrapped error value will be discarded. Declaration public Maybe<TValue> ToMaybe() Returns Type Description Maybe <TValue> | Improve this Doc View Source ToString() Produces a string format like the following: \"Ok<TValue,TError>[value]\" or \"Err<TValue,TError>[error]\". Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() | Improve this Doc View Source UnwrapOr(TValue) Safely get the value out of the Ok variant of a Result . This is the recommended way to get a value out of a Result most of the time. Declaration public TValue UnwrapOr(TValue defaultValue) Parameters Type Name Description TValue defaultValue Fallback value to be returned if this is Err . Returns Type Description TValue Examples var anOk = Result<int,string>.Ok(1); Console.WriteLine(anOk.UnwrapOr(0)); // 1 var anErr = Result<int,string>.Err(\"error\"); Console.WriteLine(anErr.UnwrapOr(0)); // 0 | Improve this Doc View Source UnwrapOrElse(Func<TError, TValue>) Safely get the value out of a Result<TValue,TError> by returning the wrapped value if it is Ok or by applying elseFn if it is Err . This is useful when you need to generate a value (e.g. by using current values in the environment ‚Äì whether preloaded or by local closure) instead of having a single default value available (as in UnwrapOr(TValue) ). Declaration public TValue UnwrapOrElse(Func<TError, TValue> elseFn) Parameters Type Name Description System.Func <TError, TValue> elseFn Function to apply to map TError to TVaue . Returns Type Description TValue Examples var someOtherValue = 2; var handleError = (string err) => err.Length + someOtherValue; var anOk = Result<int,string>.Ok(42); Console.WriteLine(anOk.UnwrapOrElse(handleError)); // 42 var anErr = Result<int,string>.Err(\"error\"); Console.WriteLine(anErr.UnwrapOrElse(handleError)); // error Operators | Improve this Doc View Source Explicit(Result<TValue, TError> to TValue) Implicit conversion operator from Result<TValue, TError> to TValue . Equivalent to result.UnsafelyUnwrap , but is helpful for eliminating unnecessary syntax. note This operator will not work if TValue and TError are the same because there will be no way for the type inference system in C‚ôØ to resolve them. Declaration public static explicit operator TValue(Result<TValue, TError> result) Parameters Type Name Description Result <TValue, TError> result Returns Type Description TValue Examples This allows us to simplify code that would otherwise be needlessly verbose. For example, without this operator we might write the following: int SomeOperation() { var resultOfOtherOperation = SomeOtherOperation(); if (resultOfOtherOperation.IsOk) { return resultOfOtherOperation.UnsafelyUnwrap(); } else { throw new Exception(\"oops! SomeOtherOperation failed!\"); } } Using this implicit conversion, this could be simplified: int SomeOperation() => return SomeOtherOperation(); note There are actually safer and more semantic methods for handling results than this, and we recommend the use of UnwrapOr(TValue) or any of the several methods provided for such use; however, we recognize that in spite of our desire to avoid exceptions and null , reality insists that sometimes we have to use them, particularly when making changes to incumbent software. | Improve this Doc View Source Explicit(Result<TValue, TError> to TError) This works similarly to Explicit(Result<TValue, TError> to TValue) , but instead of conversion to a TValue , the implicit conversion is to a TError . note This operator will not work if TValue and TError are the same because there will be no way for the type inference system in C‚ôØ to resolve them. Declaration public static explicit operator TError(Result<TValue, TError> result) Parameters Type Name Description Result <TValue, TError> result Returns Type Description TError | Improve this Doc View Source Implicit(TValue to Result<TValue, TError>) Implicit conversion operator from TValue to Result<TValue,TError> . As with the other operators, this is intended to reduce boilerplate code required by the type system and allow you to achieve maximum leverage of type inference. note This operator will not work if TValue and TError are the same because there will be no way for the type inference system in C‚ôØ to resolve them. Declaration public static implicit operator Result<TValue, TError>(TValue value) Parameters Type Name Description TValue value Returns Type Description Result <TValue, TError> Examples When constructing a Result<TValue,TError> the type system can be a little bit fussy. We might write: Result<int,string> SomeOperation() { try { int result = SomeOtherOperation(); // db query, file i/o, etc. return Result<int,string>.Ok(result); } catch (Exception exn) { return Result<int,string>.Err(exn.Message); } } Using these operators, we can write it like this: Result<int,string> SomeOperation() { try { int result = SomeOtherOperation(); // db query, file i/o, etc. return result; } catch (Exception exn) { return exn.Message; } } This will be particularly powerful when combined with similar operators defined for Maybe<TValue> when you have a return type like Result<Maybe<TValue>,TError> . | Improve this Doc View Source Implicit(TError to Result<TValue, TError>) Implicit conversion operator from TError to Result<TValue,TError> . As with the other operators, this is intended to reduce boilerplate code required by the type system and allow you to achieve maximum leverage of type inference. note This operator will not work if TValue and TError are the same because there will be no way for the type inference system in C‚ôØ to resolve them. See examples provided with Implicit(TValue to Result<TValue, TError>) . Declaration public static implicit operator Result<TValue, TError>(TError error) Parameters Type Name Description TError error Returns Type Description Result <TValue, TError> Implements System.IComparable System.IComparable<T> Extension Methods UnsafeExtensions.UnsafelyUnwrap<T, E>(Result<T, E>) UnsafeExtensions.UnsafelyUnwrapErr<T, E>(Result<T, E>)"
  }
}